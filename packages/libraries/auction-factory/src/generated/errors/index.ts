/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number }
type MaybeErrorWithCode = ErrorWithCode | null | undefined

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map()
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map()

/**
 * IncorrectOwner: 'Account does not have correct owner!'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectOwnerError extends Error {
  readonly code: number = 0x1770
  readonly name: string = 'IncorrectOwner'
  constructor() {
    super('Account does not have correct owner!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectOwnerError)
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new IncorrectOwnerError())
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError())

/**
 * Uninitialized: 'Account is not initialized!'
 *
 * @category Errors
 * @category generated
 */
export class UninitializedError extends Error {
  readonly code: number = 0x1771
  readonly name: string = 'Uninitialized'
  constructor() {
    super('Account is not initialized!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UninitializedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1771, () => new UninitializedError())
createErrorFromNameLookup.set('Uninitialized', () => new UninitializedError())

/**
 * TokenAccountNotOwnedByWinningBidder: 'Token account not owned by winning bidder'
 *
 * @category Errors
 * @category generated
 */
export class TokenAccountNotOwnedByWinningBidderError extends Error {
  readonly code: number = 0x1772
  readonly name: string = 'TokenAccountNotOwnedByWinningBidder'
  constructor() {
    super('Token account not owned by winning bidder')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenAccountNotOwnedByWinningBidderError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1772,
  () => new TokenAccountNotOwnedByWinningBidderError()
)
createErrorFromNameLookup.set(
  'TokenAccountNotOwnedByWinningBidder',
  () => new TokenAccountNotOwnedByWinningBidderError()
)

/**
 * MintMismatch: 'Mint Mismatch!'
 *
 * @category Errors
 * @category generated
 */
export class MintMismatchError extends Error {
  readonly code: number = 0x1773
  readonly name: string = 'MintMismatch'
  constructor() {
    super('Mint Mismatch!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MintMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1773, () => new MintMismatchError())
createErrorFromNameLookup.set('MintMismatch', () => new MintMismatchError())

/**
 * InactiveAuctionFactory: 'Activate auction factory before performing such action.'
 *
 * @category Errors
 * @category generated
 */
export class InactiveAuctionFactoryError extends Error {
  readonly code: number = 0x1774
  readonly name: string = 'InactiveAuctionFactory'
  constructor() {
    super('Activate auction factory before performing such action.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InactiveAuctionFactoryError)
    }
  }
}

createErrorFromCodeLookup.set(0x1774, () => new InactiveAuctionFactoryError())
createErrorFromNameLookup.set(
  'InactiveAuctionFactory',
  () => new InactiveAuctionFactoryError()
)

/**
 * TreasuryMismatch: 'Treasury mismatch!'
 *
 * @category Errors
 * @category generated
 */
export class TreasuryMismatchError extends Error {
  readonly code: number = 0x1775
  readonly name: string = 'TreasuryMismatch'
  constructor() {
    super('Treasury mismatch!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TreasuryMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1775, () => new TreasuryMismatchError())
createErrorFromNameLookup.set(
  'TreasuryMismatch',
  () => new TreasuryMismatchError()
)

/**
 * AuctionFactoryUuidInvalidLengthError: 'Uuid must be length 5'
 *
 * @category Errors
 * @category generated
 */
export class AuctionFactoryUuidInvalidLengthErrorError extends Error {
  readonly code: number = 0x1776
  readonly name: string = 'AuctionFactoryUuidInvalidLengthError'
  constructor() {
    super('Uuid must be length 5')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AuctionFactoryUuidInvalidLengthErrorError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1776,
  () => new AuctionFactoryUuidInvalidLengthErrorError()
)
createErrorFromNameLookup.set(
  'AuctionFactoryUuidInvalidLengthError',
  () => new AuctionFactoryUuidInvalidLengthErrorError()
)

/**
 * InactiveAuction: 'Auction is not in a state to perform such action.'
 *
 * @category Errors
 * @category generated
 */
export class InactiveAuctionError extends Error {
  readonly code: number = 0x1777
  readonly name: string = 'InactiveAuction'
  constructor() {
    super('Auction is not in a state to perform such action.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InactiveAuctionError)
    }
  }
}

createErrorFromCodeLookup.set(0x1777, () => new InactiveAuctionError())
createErrorFromNameLookup.set(
  'InactiveAuction',
  () => new InactiveAuctionError()
)

/**
 * AuctionResourceAlreadyExists: 'Auction resource can only be generated once.'
 *
 * @category Errors
 * @category generated
 */
export class AuctionResourceAlreadyExistsError extends Error {
  readonly code: number = 0x1778
  readonly name: string = 'AuctionResourceAlreadyExists'
  constructor() {
    super('Auction resource can only be generated once.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AuctionResourceAlreadyExistsError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1778,
  () => new AuctionResourceAlreadyExistsError()
)
createErrorFromNameLookup.set(
  'AuctionResourceAlreadyExists',
  () => new AuctionResourceAlreadyExistsError()
)

/**
 * UnsettledAuction: 'Must settle any ongoing auction before creating a new auction.'
 *
 * @category Errors
 * @category generated
 */
export class UnsettledAuctionError extends Error {
  readonly code: number = 0x1779
  readonly name: string = 'UnsettledAuction'
  constructor() {
    super('Must settle any ongoing auction before creating a new auction.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnsettledAuctionError)
    }
  }
}

createErrorFromCodeLookup.set(0x1779, () => new UnsettledAuctionError())
createErrorFromNameLookup.set(
  'UnsettledAuction',
  () => new UnsettledAuctionError()
)

/**
 * AuctionAlreadySettled: 'Auction is already settled.'
 *
 * @category Errors
 * @category generated
 */
export class AuctionAlreadySettledError extends Error {
  readonly code: number = 0x177a
  readonly name: string = 'AuctionAlreadySettled'
  constructor() {
    super('Auction is already settled.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AuctionAlreadySettledError)
    }
  }
}

createErrorFromCodeLookup.set(0x177a, () => new AuctionAlreadySettledError())
createErrorFromNameLookup.set(
  'AuctionAlreadySettled',
  () => new AuctionAlreadySettledError()
)

/**
 * AuctionIsLive: 'Auction is live and cannot be settled.'
 *
 * @category Errors
 * @category generated
 */
export class AuctionIsLiveError extends Error {
  readonly code: number = 0x177b
  readonly name: string = 'AuctionIsLive'
  constructor() {
    super('Auction is live and cannot be settled.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AuctionIsLiveError)
    }
  }
}

createErrorFromCodeLookup.set(0x177b, () => new AuctionIsLiveError())
createErrorFromNameLookup.set('AuctionIsLive', () => new AuctionIsLiveError())

/**
 * InvalidBidAmount: 'Bid must be a non-negative, non-zero amount. Bid must also beat previous bid by some percent.'
 *
 * @category Errors
 * @category generated
 */
export class InvalidBidAmountError extends Error {
  readonly code: number = 0x177c
  readonly name: string = 'InvalidBidAmount'
  constructor() {
    super(
      'Bid must be a non-negative, non-zero amount. Bid must also beat previous bid by some percent.'
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidBidAmountError)
    }
  }
}

createErrorFromCodeLookup.set(0x177c, () => new InvalidBidAmountError())
createErrorFromNameLookup.set(
  'InvalidBidAmount',
  () => new InvalidBidAmountError()
)

/**
 * NoActiveAuction: 'Cannot modify an auction that does not exist.'
 *
 * @category Errors
 * @category generated
 */
export class NoActiveAuctionError extends Error {
  readonly code: number = 0x177d
  readonly name: string = 'NoActiveAuction'
  constructor() {
    super('Cannot modify an auction that does not exist.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoActiveAuctionError)
    }
  }
}

createErrorFromCodeLookup.set(0x177d, () => new NoActiveAuctionError())
createErrorFromNameLookup.set(
  'NoActiveAuction',
  () => new NoActiveAuctionError()
)

/**
 * AuctionAddressMismatch: 'Auction address mismatch.'
 *
 * @category Errors
 * @category generated
 */
export class AuctionAddressMismatchError extends Error {
  readonly code: number = 0x177e
  readonly name: string = 'AuctionAddressMismatch'
  constructor() {
    super('Auction address mismatch.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AuctionAddressMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x177e, () => new AuctionAddressMismatchError())
createErrorFromNameLookup.set(
  'AuctionAddressMismatch',
  () => new AuctionAddressMismatchError()
)

/**
 * AuctionsAlreadyInitialized: 'Initialize auctions can only be called once.'
 *
 * @category Errors
 * @category generated
 */
export class AuctionsAlreadyInitializedError extends Error {
  readonly code: number = 0x177f
  readonly name: string = 'AuctionsAlreadyInitialized'
  constructor() {
    super('Initialize auctions can only be called once.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AuctionsAlreadyInitializedError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x177f,
  () => new AuctionsAlreadyInitializedError()
)
createErrorFromNameLookup.set(
  'AuctionsAlreadyInitialized',
  () => new AuctionsAlreadyInitializedError()
)

/**
 * BidderAlreadyWinning: 'Bidder is already winning the auction'
 *
 * @category Errors
 * @category generated
 */
export class BidderAlreadyWinningError extends Error {
  readonly code: number = 0x1780
  readonly name: string = 'BidderAlreadyWinning'
  constructor() {
    super('Bidder is already winning the auction')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, BidderAlreadyWinningError)
    }
  }
}

createErrorFromCodeLookup.set(0x1780, () => new BidderAlreadyWinningError())
createErrorFromNameLookup.set(
  'BidderAlreadyWinning',
  () => new BidderAlreadyWinningError()
)

/**
 * WrongSettleAuctionEndpoint: 'Wrong settle auction endpoint!'
 *
 * @category Errors
 * @category generated
 */
export class WrongSettleAuctionEndpointError extends Error {
  readonly code: number = 0x1781
  readonly name: string = 'WrongSettleAuctionEndpoint'
  constructor() {
    super('Wrong settle auction endpoint!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongSettleAuctionEndpointError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1781,
  () => new WrongSettleAuctionEndpointError()
)
createErrorFromNameLookup.set(
  'WrongSettleAuctionEndpoint',
  () => new WrongSettleAuctionEndpointError()
)

/**
 * AuctionHasNoResourceAvailable: 'Must supply resource to auction before settling!'
 *
 * @category Errors
 * @category generated
 */
export class AuctionHasNoResourceAvailableError extends Error {
  readonly code: number = 0x1782
  readonly name: string = 'AuctionHasNoResourceAvailable'
  constructor() {
    super('Must supply resource to auction before settling!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AuctionHasNoResourceAvailableError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1782,
  () => new AuctionHasNoResourceAvailableError()
)
createErrorFromNameLookup.set(
  'AuctionHasNoResourceAvailable',
  () => new AuctionHasNoResourceAvailableError()
)

/**
 * InvalidBidAccount: 'Invalid bid account supplied'
 *
 * @category Errors
 * @category generated
 */
export class InvalidBidAccountError extends Error {
  readonly code: number = 0x1783
  readonly name: string = 'InvalidBidAccount'
  constructor() {
    super('Invalid bid account supplied')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidBidAccountError)
    }
  }
}

createErrorFromCodeLookup.set(0x1783, () => new InvalidBidAccountError())
createErrorFromNameLookup.set(
  'InvalidBidAccount',
  () => new InvalidBidAccountError()
)

/**
 * NumericalOverflowError: 'Numerical overflow error!'
 *
 * @category Errors
 * @category generated
 */
export class NumericalOverflowErrorError extends Error {
  readonly code: number = 0x1784
  readonly name: string = 'NumericalOverflowError'
  constructor() {
    super('Numerical overflow error!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NumericalOverflowErrorError)
    }
  }
}

createErrorFromCodeLookup.set(0x1784, () => new NumericalOverflowErrorError())
createErrorFromNameLookup.set(
  'NumericalOverflowError',
  () => new NumericalOverflowErrorError()
)

/**
 * NumericalUnderflowError: 'Numerical underflow error!'
 *
 * @category Errors
 * @category generated
 */
export class NumericalUnderflowErrorError extends Error {
  readonly code: number = 0x1785
  readonly name: string = 'NumericalUnderflowError'
  constructor() {
    super('Numerical underflow error!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NumericalUnderflowErrorError)
    }
  }
}

createErrorFromCodeLookup.set(0x1785, () => new NumericalUnderflowErrorError())
createErrorFromNameLookup.set(
  'NumericalUnderflowError',
  () => new NumericalUnderflowErrorError()
)

/**
 * CheckedRemError: 'Checked REM error'
 *
 * @category Errors
 * @category generated
 */
export class CheckedRemErrorError extends Error {
  readonly code: number = 0x1786
  readonly name: string = 'CheckedRemError'
  constructor() {
    super('Checked REM error')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CheckedRemErrorError)
    }
  }
}

createErrorFromCodeLookup.set(0x1786, () => new CheckedRemErrorError())
createErrorFromNameLookup.set(
  'CheckedRemError',
  () => new CheckedRemErrorError()
)

/**
 * NumericalDivisionError: 'Numerical division error!'
 *
 * @category Errors
 * @category generated
 */
export class NumericalDivisionErrorError extends Error {
  readonly code: number = 0x1787
  readonly name: string = 'NumericalDivisionError'
  constructor() {
    super('Numerical division error!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NumericalDivisionErrorError)
    }
  }
}

createErrorFromCodeLookup.set(0x1787, () => new NumericalDivisionErrorError())
createErrorFromNameLookup.set(
  'NumericalDivisionError',
  () => new NumericalDivisionErrorError()
)

/**
 * NotAuthorized: 'Account is not authorized to take such action.'
 *
 * @category Errors
 * @category generated
 */
export class NotAuthorizedError extends Error {
  readonly code: number = 0x1788
  readonly name: string = 'NotAuthorized'
  constructor() {
    super('Account is not authorized to take such action.')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotAuthorizedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1788, () => new NotAuthorizedError())
createErrorFromNameLookup.set('NotAuthorized', () => new NotAuthorizedError())

/**
 * PublicKeyMismatch: 'Public key mismatch'
 *
 * @category Errors
 * @category generated
 */
export class PublicKeyMismatchError extends Error {
  readonly code: number = 0x1789
  readonly name: string = 'PublicKeyMismatch'
  constructor() {
    super('Public key mismatch')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PublicKeyMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1789, () => new PublicKeyMismatchError())
createErrorFromNameLookup.set(
  'PublicKeyMismatch',
  () => new PublicKeyMismatchError()
)

/**
 * TokenTransferFailed: 'Token transfer failed'
 *
 * @category Errors
 * @category generated
 */
export class TokenTransferFailedError extends Error {
  readonly code: number = 0x178a
  readonly name: string = 'TokenTransferFailed'
  constructor() {
    super('Token transfer failed')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenTransferFailedError)
    }
  }
}

createErrorFromCodeLookup.set(0x178a, () => new TokenTransferFailedError())
createErrorFromNameLookup.set(
  'TokenTransferFailed',
  () => new TokenTransferFailedError()
)

/**
 * InsufficientAccountBalance: 'Insufficient account balance!'
 *
 * @category Errors
 * @category generated
 */
export class InsufficientAccountBalanceError extends Error {
  readonly code: number = 0x178b
  readonly name: string = 'InsufficientAccountBalance'
  constructor() {
    super('Insufficient account balance!')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InsufficientAccountBalanceError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x178b,
  () => new InsufficientAccountBalanceError()
)
createErrorFromNameLookup.set(
  'InsufficientAccountBalance',
  () => new InsufficientAccountBalanceError()
)

/**
 * ForcedError: 'Forced error'
 *
 * @category Errors
 * @category generated
 */
export class ForcedErrorError extends Error {
  readonly code: number = 0x178c
  readonly name: string = 'ForcedError'
  constructor() {
    super('Forced error')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ForcedErrorError)
    }
  }
}

createErrorFromCodeLookup.set(0x178c, () => new ForcedErrorError())
createErrorFromNameLookup.set('ForcedError', () => new ForcedErrorError())

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code)
  return createError != null ? createError() : null
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name)
  return createError != null ? createError() : null
}
